Как говорилось ранее, существует три стиля юнит-тестирования:
- Проверка выходных данных
- Проверка состояния
- Проверка взаимодействий

Первый стиль юнит-тестирования это проверка выходных данных, он проверяет конечный результат, но подходит не во всех случаях. Если код изменяет глобальное или внутреннее состояние, то этот стиль тестирования не подойдет, так как проверить нужно не только возвращаемое значение.

Следующий стиль юнит-тестирования это проверка состояния, где тест проверяет состояние системы, после выполнения кода. Проверять можно как состояние самой тестируемой системы, её коллабораторов, так и внепроцессных зависимостей, например, база данных.

Последним стилем юнит-тестирования является проверка взаимодействий. Этот стиль использует моки для проверки взаимодействий между тестируемой системой и её коллабораторами. 

Метрика простоты поддержки сильно зависит от стиля юнит-тестирования, но в отличии от устойчивости к рефакторингу, вы мало что можете сделать.

Тесты, проверяющие состояние, обычно обладают худшей сопровождаемостью, чем тесты, проверяющие выходные данные.

Сравнение стилей:

|  | Проверка выходных данных | Проверка состояния | Проверка взаимодействия |
| ---- | ---- | ---- | ---- |
| Особое внимание к рефакторингу | Низкое | Среднее | Среднее |
| Затраты на сопровождение | Низкие | Средние | Высокие |

Старайтесь отдавать предпочтение проверке выходных данных. К сожалению, проще сказать, чем сделать. Этот стиль юнит-тестирования подходит только к коду написанному в функциональном стиле.

**Побочные эффекты (side effects)** - результаты, которые не показываются в сигнатуре метода, а следовательно являются скрытыми. Операция создает побочный эффект при изменении состояния экземпляра класса, обновлении файла на диске и т.д.

Разделение бизнес-логики и побочных эффектов осуществляется посредством изоляции двух типов кода:
- код, принимающий решение. Этот код не требует побочных эффектов.
- код, действующий по результатам этого решения.

Код принимающий решение называется функциональным ядром (functional core). Код, действующий по результатам этого решения называется изменяемой оболочкой (mutable shell).

ООП делает код более понятным за счет инкапсуляции подвижных частей. Функциональное программирование делает код более понятным за счет минимизации количества подвижных частей.

Читаемость теста можно улучшить за счёт использования структур, вместо классов, что дает возможность делать сравнение не по ссылке, а по значению.

В разных случаях нужно применять разные инструменты, единственно верного решения не существует.

Цель этой главы заключалось не в том, чтобы вы перевели все свои тесты на функциональную архитектуру, а чтобы сделали это как можно с большим количеством тестов.
