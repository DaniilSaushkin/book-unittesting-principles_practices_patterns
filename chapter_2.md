Юнит-тест соответствует трём принципам:
- Проверка правильной работы фрагмента кода (Юнита) (обычно юнитом называется один класс или один метод внутри класса.)
- Быстрота выполнения теста
- Изолирован от другого кода

Есть классический подход и лондонский в понимании третьего пункта про «Изоляцию».

Лондонский подход заключается в том, что необходимо для зависимостей кода, который мы тестируем, создать заглушки, тогда мы всегда будем знать, что именно не работает. У зависимостей также могут быть и свои зависимости и так далее…

**SUT** – System Under Test (Тестируемая система).

**MUT** – Method Under Test (Тестируемый метод).

MUT и SUT часто используют как синонимы, но MUT это тестируемый метод, а SUT весь класс.

**Mocks** – разновидность заглушек – особая разновидность заглушки, которая помогает протестировать взаимодействие между SUT и коллаборатором. Для C# хороший фреймворк – Moq или NSubtitute.

Термины «Заглушка» и «Мок» часто используют как синонимы, но это неверно:
- **Тестовая заглушка** – общий термин, описывающий любые разновидности фиктивных зависимостей в тестах
- **Мок** – одна из этих разновидностей

Получается следующее, лондонский подход рассматривает изоляцию как отдельное тестирование SUT от его коллабораторов с помощью моков.

Классический подход не запрещает тестировать несколько классов одновременно, как в лондонском подходе, но они не должны быть подвержены влиянию со стороны, например, база данных или файловая система. Один тест может создать запись, а другой тест может удалить эту запись, то того, как отработает первый тест и тогда тест на удаление будет провален, но не потому, что он работает неправильно, а потому что подвергается влиянию со стороны другого теста.

**Совместная (shared) зависимость** — это зависимость, к которой имеют доступ более одного теста, что позволяет им влиять друг на друга.

**Приватная (private) зависимость** – это зависимость, которая не является совместной.

**Внепроцессная (out-of-process) зависимость** – это зависимость, которая работает вне процесса приложения, например, база данных. Кстати, база данных, также является совместной зависимостью, кроме случаев, когда запускается отдельный Docker-контейнер, тогда у каждого теста будет свой экземпляр базы данных. И база данных только для чтения, тоже не будет является совместной, хотя доступ к ней имеют более одного теста, но они не могут влиять друг на друга.

**Нестабильная (volatile) зависимость** – это зависимость, в которой есть одно из следующих свойств:
- Наличие недетерминированного поведения. Например, метод, который отдает разные данные при обращении к нему (Генератор случайных чисел)
- Необходимость подготовки и настройки среды в дополнение к той, что устанавливается на машине разработчика

Разница подходов:

| |**Изоляция**|**Юнит - это**|**Использование моков для**|
|---|---|---|---|
|_Лондонская школа_|Юнитов|Класс|Коллабораторов (любых изменяемых зависимостей)|
|_Классическая школа_|Юнит-тестов|Класс или набор|Совместных (shared) зависимостей|

**Коллабораторы (Collaborators)** – это изменяемые зависимости. Например, класс, которые предоставляет доступ к базе данных, если доступ не только для чтения. То есть коллаборатор это тот, кто работает за счёт других классов или объектов.

**Объект-значение (Value object)** — это объект, чья идентичность представляется его значением. То есть объект уникален, только из-за его значения, например, объект «Дата», которая хранит в себе только текущую дату.

Получается разница в том, что объект-значение предоставляет свои независимые данные, а коллаборатор предоставляет данные с помощью других классов или объектов.

Плюсы лондонского подхода:
- Улучшенная детализация
- Упрощение юнит-тестирования большого графа взаимосвязанных классов
- Если тест падает, то вы точно знаете, в какой функциональности произошёл сбой, так как все коллабораторы заменены заглушками

**Тест должен проверять не единицу кода, а единицу поведения системы**.

При классическом подходе, если сломался код и тесты прошли с ошибками каскадно, то значит этот код очень важный. Также при классическом подходе нужно будет учитывать все графы взаимосвязей и юнит-тесты помогают увидеть большое количество взаимосвязей сразу, что даст понимание где возможно есть архитектурные ошибки в коде.

**Test Driven Development** – Разработка через тестирование. Вот его принципы:
- Изначально пишется тест и проверяется, выдаст ли он отрицательный результат, а затем уже пишется код, который должен будет пройти через тест
- Выполняется рефакторинг кода, если это нужно, так как изначально код может быть не самым чистым. А также при рефакторинге уже будет тест, который покажет разработчику на ошибку, в случае её наличия и поможет разработчику увереннее разрабатывать код

Принципы юнит-теста со взгляда классической школы:
- Проверяет одну **единицу поведения** (а не единицу кода)
- Делает это быстро
- И в изоляции **от других тестов** (а не от другого кода)

**Интеграционный тест** – это тест, который проверяет интеграцию с другими частями системы, например, база данных, файловая система и так далее, то есть внепроцессные зависимости и совместные зависимости.

**End-to-end тест (Сквозной)** – это тоже интеграционный тест, только в большем масштабе, например, другая программа, этой программой может быть какой-нибудь платежный шлюз.