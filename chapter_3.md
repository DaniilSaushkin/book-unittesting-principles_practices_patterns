Четкой границы между этими тестами нет, считается что End-to-end тест проверяет всю систему целиком, либо её большую часть, в то время как интеграционный тест проверяет единицу поведения с внепроцессными и совместными зависимостями.

Паттерн Given-When-Then это тоже самое что и паттерн AAA – Arrange, Act, Assert.

**Паттерн** **AAA** – Arrange Act Assert (Подготовка, Действие и Проверка) – это паттерн, где тест разбивается на три части, это **Arrange, где идёт подготовка данных** перед тестом, например, создание нужного экземпляра класса и т.д., далее идёт **Act это действие**, выполняется тестируемое поведения, например, метод класса, а затем идёт часть **Assert, то есть проверка**, где сравнивается ожидаемый результат и полученный результат.

Нужно избегать повторений этих частей, то есть не должно быть такого, что идёт структура типа Arrange -> Act -> Arrange -> Assert -> Act -> Assert и тому подобное, так как это усложняет логику и сопровождение теста, а также является антипаттерном. К этому можно добавить конструкции if и switch, логика теста не должна ветвиться.

Важно выделять тестируемую систему (класс), она должна называться SUT (system under test, тестируемая система), это упрощает понимание теста.

Если тест маленький и вы можете избежать пробелов в блоке Arrange или в Assert, то нужно удалять комментарии к паттерну AAA, если нет, то можно оставить комментарии, которые явно разделяют эти блоки (// Arrange, // Act // Assert).

xUnit удобен тем, что не требует дополнительных настроек, а работает с инструментами, которые даёт сам язык C#, например, если нужно почистить данные после теста, это можно сделать с помощью реализации метода Dispose(), предварительно унаследовавшись от интерфейса IDisposable. Метод Dispose() будет выполняться после каждого теста.

Также, не лучшая идея использовать конструктор тестового класса, как подготовку данных к каждому тесту, лучше написать приватные фабричные методы, которые будут создавать нужные экземпляры классов для тестов.

**Нужно использовать разговорные имена для названия тестов.** Называйте тесты так, будто вы описываете поведение, которое тестируется. Давайте им такие имена, чтобы они были понятны непрограммисту.